export const metadata = {
    title: "Generating UI with Structured Outputs",
    date: "2025-09-12",
    author: "Dexter Storey, Sarim Malik",
    bannerImageUrl: "/images/monolith.png",
    category: "Structured Outputs",
    description: "Learn how to leverage structured outputs from LLMs to dynamically generate user interfaces, including practical techniques, schema design, and real-world examples for building adaptive, data-driven UIs."
}

<Callout>
**TLDR:** Try it for yourself in this [playground](https://views.rubric.sh/).
</Callout>

It's easy to start building AI-generated UI, but hard to ship.

Here's the core problem: how do we reliably go from natural language to code to a working UI? And even if the UI is functional, how do we make it pleasant to use?

If you ask a model to write UI code, you often end up in [purple hell](https://x.com/ryandavogel/status/1956365206147244167). It all looks the same and you immediately know it's AI generated. Simon Willison would describe this as ["slop"](https://simonwillison.net/2024/May/8/slop/).

[image]: a generic prompt and the generated UI 

Even with strong primitives like [shadcn/ui](https://ui.shadcn.com/), code generation can improve how it looks, but it is still brittle and tied to your environment.
Generating code on the fly is not viable for end users. It is slow: write, build, bundle. It is also failure prone: type errors, missing imports, and runtime mismatches.

A better approach is to generate JSON, not code.

LLMs are good at JSON when you give them a schema. You can validate it, render it, and recover when something goes wrong.

## Structured outputs, briefly

Structured outputs are responses that match a schema you define, like JSON objects with specific fields and types. Instead of free text, you get machine-checkable data.

Why this works well with LLMs
- LLMs can follow constraints when you give them a clear target. A JSON Schema is that target.
- With tooling, you can ask for exact shapes, enums, and nested structures and reject anything that does not match.

Practical constraints to keep in mind
- Objects have limits on nesting depth and size. Plan for truncation or progressive disclosure of detail.
- Use focused schemas for each task. Smaller schemas are easier for the model to satisfy.
- Always validate on the server before rendering. Treat the model output like user input.

Source: OpenAI structured outputs guide. See details and limits [in the docs](https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses&example=ui-generation#objects-have-limitations-on-nesting-depth-and-size).

## Everything is Schema

Let me put it plainly. When you strip away the paint, UI is just data. Components, props, layout, bindings, even interactions can all be expressed as a schema. If we agree on that schema up front, we get a single source of truth that both the model and the renderer understand. No guesswork. No hidden magic.

This schema first approach works because it is predictable and safe. The same input always renders the same UI. Every change is validated by Zod before it reaches the screen. You can update only a small part of the tree, merge it back, and keep going. The JSON travels well too. The same structure can render on the web, on mobile, or on the server. And once you have a schema, you unlock tooling like visual editors, diffs, and automatic migrations.

Structured outputs are the bridge between the idea and the pixels. The model does not send prose, it sends JSON that targets your schema. You validate it on the server, then render it if it passes. If it does not pass, you show the issues or ask the model for a smaller, focused fix. Simple contract, tight loop.

## How It Works

### Define your components with Zod
- Give every UI primitive its own props schema.
- Combine them into a master `ComponentsSchema` that describes valid UI trees.

### Prepare the schema for the model
- Turn your Zod schema into JSON Schema with `z.toJSONSchema(..., { metadata: SchemaRegistry })`.
- Optionally limit which components are allowed and set sensible defaults.

### Ask the model for structured output
- Send a simple system prompt that explains the job: “turn requests into a UI.”
- Include the current UI state so the model can update in place.
- Request output that matches your JSON Schema.

### Validate the result
- Parse the model’s JSON and run `ComponentsSchema.safeParse(...)`.
- If it fails validation, return the issues and do not render.

### Render the UI
- Map the validated JSON tree to your React components at runtime.
- No code generation. No build step. It renders immediately.

### Iterate safely
- For each edit, send the current state and the user’s change.
- The model updates the existing tree instead of starting from scratch.
- Support incremental updates: point the model at a specific subtree (by id or path) and ask for only that part to be regenerated. Merge the validated diff back into the current state.

[image] Data flow at a glance: User prompt → API route → Model with JSON Schema → JSON output → Zod validation → UI render.

## Lessons from scaling

## Why this matters


